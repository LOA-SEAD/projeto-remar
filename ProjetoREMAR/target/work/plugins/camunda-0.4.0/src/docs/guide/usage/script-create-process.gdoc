You can create a *BPMN 2.0* process definition by issueing the following command:

{code:bash}
grails create-process [name]
{code}

As [name] choose a 'package and class' like name of your choice, e.g. "*org.camunda.my.TestProcess*".
You should see the following two files generated by Grails:

{code:bash}
| Created file grails-app/processes/org/camunda/my/TestProcess.bpmn
| Created file test/integration/org/camunda/my/TestProcessSpec.groovy
{code}

You may now want to look at the generated BPMN process definition by making use of [camunda
modeler|http://camunda.org/bpmn/tool/]. It's a minimal process, but enough to get you started with user tasks and
services and to build upon:

!TestProcessModeler.png!

Furthermore you will find a 'spock' based integration spec executing and checking that process. It
does have a bit more content than your typical almost empty Grails spec template...

{code}
[...]
given: "a new instance of TestProcess"
runtimeService.startProcessInstanceByKey("TestProcess")

when: "completing the user task"
def task = taskService.createTaskQuery().singleResult()
taskService.complete(task.id)

then: "the service method defined for the subsequent service task was called exactly once"
1 * sampleTestProcessService.serviceMethod(_ as Execution)
[...]
{code}

... again to get you started with typical process testing boilerplate readily adapted to your freshly created
process definition and to build upon. Please check out the chapter about [conventions|guide:conventions] in order
to fully appreciate the consequences of the process template being generated for you.
